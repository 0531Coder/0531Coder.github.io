<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[在view渲染出来之前获取view的宽高]]></title>
      <url>%2F2017%2F04%2F07%2Fget%20view%20width%20and%20height%2F</url>
      <content type="text"><![CDATA[获取view的宽高。 在学习自定义控件的时候需要在view渲染出来之前获取到该view的宽高，如果直接获取宽高会是0，所以在网上搜到了以下几个方法。用博客记录下来。 普通的做法LayoutInflater.from(context).inflate(R.layout.float_window_small, this); View view = findViewById(R.id.float_window_small); viewHeight = view.getWidth(); viewWidth = view.getHeight(); System.out.println(&quot;measure width=&quot; + viewWidth + &quot; height=&quot; + viewHeight); 在view渲染出来的情况下，这种方法是能够获取到宽高的。但是在onCreate()、onStrart()、onResume()方法中会返回0，这是应为当前activity所代表的界面还没显示出来没有添加到WindowPhone的DecorView上或要获取的view没有被添加到DecorView上或者该View的visibility属性为gone 或者该view的width或height真的为0 所以只有上述条件都不成立时才能得到非0的width和height。如果要使用这种方法获取view的宽高建议： 在回调（点击事件、触摸事件、焦点事件）中测量。要保证获取宽高的view是在setContentView时设进去的View或它的子View。 在activity被显示出来时即添加到了DecorView上时获取宽和高如onWindowFocusChanged()回调方法。要保证获取宽高的view是在setContentView时设进去的View或它的子View。 @Override public void onWindowFocusChanged(boolean hasFocus) { View iv1 = findViewById(R.id.iv1); View iv2=findViewById(R.id.iv2); String msg1=&quot;iv1&apos; width:&quot;+iv1.getWidth()+&quot; height:&quot;+iv1.getHeight()+&quot; measuredWidth:&quot;+iv1.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv1.getMeasuredHeight(); String msg2=&quot;iv2&apos; width:&quot;+iv2.getWidth()+&quot; height:&quot;+iv2.getHeight()+&quot; measuredWidth:&quot;+iv2.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv2.getMeasuredHeight(); i(&quot;onWindowFocusChanged() &quot;+msg1); i(&quot;onWindowFocusChanged() &quot;+msg2); super.onWindowFocusChanged(hasFocus); } 在onResume方法最后开线程300毫秒左右后获取宽和高 因为onResume执行完后300毫秒后 界面就显示出来了。 view.postDelayed(new Runnable() { @Override public void run() { View iv1 = findViewById(R.id.iv1); View iv2=findViewById(R.id.iv2); String msg1=&quot;iv1&apos; width:&quot;+iv1.getWidth()+&quot; height:&quot;+iv1.getHeight()+&quot; measuredWidth:&quot;+iv1.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv1.getMeasuredHeight(); String msg2=&quot;iv2&apos; width:&quot;+iv2.getWidth()+&quot; height:&quot;+iv2.getHeight()+&quot; measuredWidth:&quot;+iv2.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv2.getMeasuredHeight(); i(&quot;onWindowFocusChanged() &quot;+msg1); i(&quot;onWindowFocusChanged() &quot;+msg2); } }, 300); 在onCreate()或onResume()等方法中监听视图树来获取，获取完后记得让view删除该回调。 view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { view.postDelayed(new Runnable() { @Override public void run() { View iv1 = findViewById(R.id.iv1); View iv2=findViewById(R.id.iv2); String msg1=&quot;iv1&apos; width:&quot;+iv1.getWidth()+&quot; height:&quot;+iv1.getHeight()+&quot; measuredWidth:&quot;+iv1.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv1.getMeasuredHeight(); String msg2=&quot;iv2&apos; width:&quot;+iv2.getWidth()+&quot; height:&quot;+iv2.getHeight()+&quot; measuredWidth:&quot;+iv2.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv2.getMeasuredHeight(); i(&quot;onWindowFocusChanged() &quot;+msg1); i(&quot;onWindowFocusChanged() &quot;+msg2); } }, 300); } }); 取消视图树监听 if(Build.VERSION.SDK_INT&gt;=16){ tv.getViewTreeObserver().removeOnGlobalLayoutListener(this); }else{ tv.getViewTreeObserver().removeGlobalOnLayoutListener(this); } 渲染之前获取的方法：LayoutInflater.from(context).inflate(R.layout.float_window_small, this); View view = findViewById(R.id.float_window_small); int w = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); int h = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); view.measure(w, h); viewHeight = view.getMeasuredHeight(); viewWidth = view.getMeasuredWidth(); System.out.println(&quot;measure width=&quot; + viewWidth + &quot; height=&quot; + viewHeight);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java反射（Reflection）详解]]></title>
      <url>%2F2017%2F03%2F13%2F%E5%8F%8D%E5%B0%84_3%2F</url>
      <content type="text"><![CDATA[接上篇上一篇博客介绍： 通过反射获取一个类的属性 通过反射获取一个类的方法并且调用该方法 通过反射获取一个类的接口 通过反射获取一个类的父类 Array工具类对数组的操作 补充通过反射对一个类中的私有属性和方法进行访问 在本篇博客中我说一下动态代理的实现。 动态代理动态代理实际上是代理模式的实现代理模式： 代理模式是java常用的设计模式，他的特征是代理类与委托类实现同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类、以及事后处理消息（或者进行相应的操作）。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对相关联，代理类的对象并不真正实现服务，而是通过调用委托类的相关方法，来提供特定的服务。 jdk动态代理中包含了reflect包下的一个类和一个接口：InvocationHandler接口： public interface InvocationHandler(){ public Object invoke(Object proxy,Method method,Object[] args) throws Throwable; } 参数说明： Object proxy 指被代理的对象 Method method 指要调用的方法 Object[] args 方法调用时所需要的参数 Proxy类：Proxy类是专门完成代理的操作类，可以通过此类为一个或者多个接口动态的生成实现类，此类提供了如下的操作方法： public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvokcationHandler h) throws IllegalArgumentException{ } 参数说明： ClassLoader：类加载器 Class&lt;?&gt;[] interfaces ：得到全部的接口 InvokcationHandler h ：得到InvokcationHandler接口的子类实例类加载器：在Proxy类中的newProxyInstance()方法中需要一个ClassLoader类的实例，ClassLoader对应的是类加载器，在java中主要有一下三种类加载器: Booststrap ClassLoader：负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类。 Extendsion ClassLoader：负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包。 App ClassLoader：负责加载classpath中指定的jar包及目录中class。 Custom ClassLoader：属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader 加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 （Tinker就是根据这个原理实现的）对加载器的描述来自这篇博文，原文讲解了java中一个类加载的过程个人觉得说的很透彻结合代码来说一下动态代理：写一个接口： public interface Dinner { //吃饭的方法 public abstract void eat(); }写一个委托类（实现了上述接口）： public class EatDinner implements Dinner { @Override public void eat() { System.out.println(&quot;吃饭&quot;); } } 写一个代理类实现InvocationHandler（）接口： public class EatDinnerProxy implements InvocationHandler { private Object originalObject; /** * 构造方法，构造目标对象 * @param target 委托类的对象 */ public EatDinnerProxy(Object target){ this.originalObject = target; } /** * 执行目标对象的方法 * @param proxy * @param method * @param args * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = null; eatBefore(); result = method.invoke(originalObject,args); eatAfter(); return result; } private void eatAfter() { System.out.println(&quot;吃饭之后&quot;); } private void eatBefore() { System.out.println(&quot;吃饭之前&quot;); } public Object getProxy(){ return Proxy.newProxyInstance(originalObject.getClass().getClassLoader(),originalObject.getClass().getInterfaces(),this); } } 测试类： public class DynamicProxyTest { public static void main(String[] args){ EatDinner eatDinner = new EatDinner(); Dinner dinner = (Dinner) new EatDinnerProxy(eatDinner).getProxy(); dinner.eat(); } } 到这里就实现了一个动态代理，但是对动态代理的原理还是没有彻底搞明白。这篇文章可能会有帮助 。 总结回顾反射的目的就是为了学习Annotation相关的额知识，所以接下来的博客我会重点找Annotation相关的资料来看，争取吃透Annotation在android中的使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java反射（reflection）详解]]></title>
      <url>%2F2017%2F03%2F13%2F%E5%8F%8D%E5%B0%84_2%2F</url>
      <content type="text"><![CDATA[接上篇上一篇博客介绍了反射的基本概念： 运行时获取到一个Class 获取该类的构造方法 动态实例化这个类 这篇博客说一下怎样通过反射获取类的属性、方法、接口、该类的父类、以及通过反射实现Array工具类对数组的操作 先贴上这篇文章中用到的bean类 public class Person { private String name; private int age; public boolean isSomking; public Person(){} public Person(String name,int age){ this.name = name; this.age = age; } Person(String name){ this.name = name; } private Person(int age){ this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String toString() { return &quot;姓名：&quot;+this.getName()+&quot;,年龄：&quot;+this.getAge(); } } public class Animal { public String name; private int age; boolean isLand; public void eat(){ System.out.println(&quot;动物在吃饭&quot;); } private void sleep(){ System.out.println(&quot;动物在睡觉&quot;); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public boolean isLand() { return isLand; } public void setLand(boolean land) { isLand = land; } } public class Cat extends Animal implements View.OnClickListener,Serializable{ public void run(String name,int age){ System.out.println(&quot;一只&quot; + age + &quot;岁的叫&quot; + name +&quot;的猫在跑&quot;); } public void run(){ System.out.println(&quot;猫在跑&quot;); } private void jump(){ System.out.println(&quot;猫在跳&quot;); } public static void main (String[] args){ Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Cat&quot;); Cat cat = (Cat) c.newInstance(); Method method = c.getDeclaredMethod(&quot;jump&quot;,null); method.invoke(cat,null); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } @Override public void onClick(View v) { } } 属性（Field）通过反射获取属性信息和获取构造方法相似，不赘述。public class FieldDemo { public static void main(String[] args) { Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Person&quot;); //方法一：获取所有公有类型的属性 System.out.println(&quot;获取所有的公有属性：&quot;); Field[] fields = c.getFields(); for (int i = 0; i &lt; fields.length; i++) { System.out.println(fields[i]); } //方法二：获取指定的公有属性 System.out.println(&quot;获取指定的公有属性：&quot;); Field field = c.getField(&quot;isSomking&quot;); System.out.println(field.toGenericString()); //方法三：获取所有的属性（不限制级别） System.out.println(&quot;获取所有的属性：&quot;); Field[] privateFields = c.getDeclaredFields(); for (int i = 0; i &lt; privateFields.length; i++) { System.out.println(privateFields[i]); } //方法四：获取指定的属性（不限制级别），但是这儿获取的私有属性是不能被访问的。 System.out.println(&quot;获取指定的属性：&quot;); Field privateField = c.getDeclaredField(&quot;age&quot;); System.out.println(privateField); } catch (ClassNotFoundException ex) { ex.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } } } 方法（Method）通过反射获取方法和获取构造方法相似，不赘述。public class MethodDemo { public static void main(String[] args) { Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Cat&quot;); //获取类中所有的公有方法（该方法会将父类的公有方法一并得出） System.out.println(&quot;获取类中所有的公有方法&quot;); Method[] methods = c.getMethods(); for(int i = 0;i&lt;methods.length;i++){ System.out.println(methods[i]); } //获取类中指定参数的公有的方法 System.out.println(&quot;获取类中指定参数的公有方法&quot;); Method method = c.getMethod(&quot;run&quot;,new Class[]{String.class,int.class}); System.out.println(method.toGenericString()); //获取所有的方法（不限制级别）这儿只能获取到本类中的不限制级别方法。 System.out.println(&quot;获取所有的方法（不限制级别）&quot;); Method[] privateMethods = c.getDeclaredMethods(); for(int i = 0;i&lt;privateMethods.length;i++){ System.out.println(privateMethods[i]); } //获取指定参数的方法（不限制级别）如果没有参数注意同上一篇的获取构造方法 System.out.println(&quot;获取指定参数的方法（不限制级别）&quot;); Method privateMethod = c.getDeclaredMethod(&quot;jump&quot;,null); System.out.println(privateMethod.toGenericString()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } } } 通过反射调用Class中的方法（method.invoke()） 首先生成一个Class的对象 获取到你要调用的方法 使用要调用方法的invoke(class,params) 注意：私有方法只能在本类中调用。这儿所说的本类是指方法所在的类。 public class MethodDemo { public static void main(String[] args) { Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Cat&quot;); //获取类中所有的公有方法（该方法会将父类的公有方法一并得出） System.out.println(&quot;获取类中所有的公有方法&quot;); Method[] methods = c.getMethods(); for(int i = 0;i&lt;methods.length;i++){ System.out.println(methods[i]); } //获取类中指定参数的公有的方法 System.out.println(&quot;获取类中指定参数的公有方法&quot;); Method method = c.getMethod(&quot;run&quot;,new Class[]{String.class,int.class}); System.out.println(method.toGenericString()); //获取所有的方法（不限制级别）这儿只能获取到本类中的不限制级别方法。 System.out.println(&quot;获取所有的方法（不限制级别）&quot;); Method[] privateMethods = c.getDeclaredMethods(); for(int i = 0;i&lt;privateMethods.length;i++){ System.out.println(privateMethods[i]); } //获取指定参数的方法（不限制级别）如果没有参数可以传null System.out.println(&quot;获取指定参数的方法（不限制级别）&quot;); Method privateMethod = c.getDeclaredMethod(&quot;jump&quot;,null); System.out.println(privateMethod.toGenericString()); //调用一个Class的方法 注意这儿不能调用类的私有方法，私有方法只能在本类中调用 // Cat cat = (Cat) c.newInstance(); // privateMethod.invoke(cat,null); System.out.println(&quot;通过反射调用class中的方法&quot;); Cat cat = (Cat) c.getConstructor().newInstance(); method.invoke(cat, new Object[]{&quot;小花&quot;,2}); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } 通过反射获取一个类中的接口信息（Interface）首先让Person实现两个接口，然后通过反射获取到该类实现的接口信息 public class InterfaceDemo { public static void main(String[] args){ Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Cat&quot;); Class[] interfaces = c.getInterfaces(); for(int i = 0;i&lt;interfaces.length;i++){ System.out.println(interfaces[i].toString()); } } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 通过反射获取一个类的父类信息（SuperClass）public class SuperClassDemo { public static void main(String[] args){ Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Cat&quot;); Class clazz = c.getSuperclass(); System.out.println(clazz.toString()); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 通过Array来操作数组（Array提供动态的访问或者生成数组的方法）（Array）public class ArrayDemo { public static void main(String[] args) { Person[] persons = new Person[]{ new Person(&quot;路人甲&quot;, 18), new Person(&quot;路人乙&quot;, 19), new Person(&quot;路人丙&quot;, 20) }; Array.set(persons,0,new Person(&quot;修改&quot;,0)); for (int i = 0;i&lt;persons.length;i++){ System.out.println(persons[i]); } System.out.println(Array.getLength(persons)); } } 补充（AccessableObject） 上面说到通过反射获取到类的私有属性和方法的时候无法访问或者调用，于是翻看reflect包下的AccessableObject类，有如下发现。 The AccessibleObject class is the base class for Field, Method and Constructor objects. It provides the ability to flag a reflected object as suppressing default Java language access control checks when it is used. The access checks–for public, default (package) access, protected, and private members–are performed when Fields, Methods or Constructors are used to set or get fields, to invoke methods, or to create and initialize new instances of classes, respectively. 由于英语没有过六级，只能理解大体意思：就是通过反射进行获取属性、构造方法、方法会进行安全检查。但是下面它提供了这样的一个方法： public void setAccessible(boolean flag) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) sm.checkPermission(ACCESS_PERMISSION); setAccessible0(this, flag); } private static void setAccessible0(AccessibleObject obj, boolean flag) throws SecurityException { if (obj instanceof Constructor &amp;&amp; flag == true) { Constructor&lt;?&gt; c = (Constructor&lt;?&gt;)obj; Class&lt;?&gt; clazz = c.getDeclaringClass(); if (clazz == Class.class) { throw new SecurityException(&quot;Can not make a java.lang.Class&quot; + &quot; constructor accessible&quot;); } else if (clazz == Method.class) { throw new SecurityException(&quot;Can not make a java.lang.reflect.Method&quot; + &quot; constructor accessible&quot;); } else if (clazz == Field.class) { throw new SecurityException(&quot;Can not make a java.lang.reflect.Field&quot; + &quot; constructor accessible&quot;); } } obj.override = flag; } 设置flag为true，可以压制java的安全检查。于是我就试着对私有的方法和属性进行操作： public class AccessableDemo { public static void main(String[] args) { Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Person&quot;); //获取私有的属性 Field field = c.getDeclaredField(&quot;age&quot;); System.out.println(&quot;获取私有属性&quot; + field); //获取私有的方法 Method method = c.getDeclaredMethod(&quot;Somking&quot;, null); System.out.println(method); //使用空参构造动态实例化对象 Person p = (Person) c.newInstance(); //访问私有属性 field.setAccessible(true); field.set(p, 20); //调用私有方法 method.setAccessible(true); method.invoke(p, null); //验证私有属性的访问 System.out.println(p.getAge()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } 结果是实现了通过反射对类私有属性和私有方法的访问。 总结 通过反射获取类的属性、方法、接口、该类的父类、以及通过反射实现Array工具类对数组的操作。 通过反射访问类中私有的属性和方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java反射（reflection）详解]]></title>
      <url>%2F2017%2F03%2F13%2F%E5%8F%8D%E5%B0%84_1%2F</url>
      <content type="text"><![CDATA[写在前面 前几天在网上看到了一篇基于AOP编程的代码，里面用到了动态代理，还有Annotation，感觉比较先进，想分析一下，然后又重新拾起了javase中的反射温习了一遍。并在blog中记录下来。 什么是反射JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。–from 百度 我理解的反射：在运行时，你获取了一个指向某个编译时不存在你的程序空间中的对象的引用，并且可以获取这个引用的属性和方法以及构造方法。 至于编译时、运行时、编译型语言、解释型语言、类加载器、动态加载类，这些概念大体解释一下： 编译时：将.java文件转换成.class文件的过程。 运行时:程序的执行过程，在java中类加载器加载.class文件，并交给jvm处理的过程。 编译型语言：将源代码一次性全部转换为机器代码（二进制代码），然后再执行程序，以后执行这个程序时就不需要再编译了。例如：C\C++编译一次后就直接生成机器语言。 解释型语言：是在运行的时候将程序翻译成机器语言，所以运行速度相对于编译型语言要慢。例如：java\C#，虽然java在执行之前要进行一次编译，但是编译生成的不是机器语言，所以说java也是一种解释性语言。脚本语言是解释型语言。 编译型语言和解释型语言的区别：编译型语言效率高，依赖于编译器，但是跨平台差。解释型的效率低，依赖于解释器，但跨平台强。 类加载器：类加载器就是JVM中的类装载器，作用就是将编译好的.class字节码运到检查器进行安全检查的，检查通过后开始解释执行。 运行时动态加载类：利用反射的原理，调用Class.forName(“ClassName”)方法，获取到的某个类（拿到的不是类的对象）。 静态加载类：new ClassName()。与运行时动态加载类的区别就是：静态加载类在编译时该类不能缺席(会报错)，但是运行时动态加载类在编译时，该类可以缺席（不会报错）。 反射的作用 Spring中IOC（控制反转）、AOP（面向方面编程）。 Hibernate框架：关联映射等。 白盒测试、使用无法反编译的API等。 反射相关APIjava.lang包下：Class: 表示一个正在运行的Java应用程序中的类或者接口，是Reflection的起源。 java.lang.reflect包下： Field类：代表类的成员变量（属性） Method类：代表类的方法。 Constructor类：代表类的构造方法。 Array类：提供了动态创建数组以及访问数组的元素的静态方法。 反射的实现生成一个正在运行的类对象，有四种方法： 使用对象的的getClass()方法。 使用static method ClassforName()。 使用.class语法。 如果是java封装类型使用Type语法。 public class ReflectDemo { public static void main(String[] args) { Class&lt;?&gt; c1 = null; Class&lt;?&gt; c2 = null; Class&lt;?&gt; c3 = null; Class&lt;?&gt; c4 = null; c1 = Person.class; try { c2 = Class.forName(&quot;com.example.lwhome.reflectdemo.Person&quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Person p = new Person(); c3 = p.getClass(); c4 = Integer.TYPE; System.out.println(c1.getName()); System.out.println(c2.getName()); System.out.println(c3.getName()); System.out.println(c4.getName()); } } 获取一个类的构造方法有以下四种方式： Constructor getConstructor(Class params)–获得类的指定参数类型的公共构造函数。 Constructor[] getConstructors()–获取类的所有的公共构造函数。 Constructor getDeclaredConstructor(Class params)–获取类的指定参数类型的构造函数（不限制访问级别） Constructor[] getDeclaredConstructor()–获取类所有的构造函数（不限制访问级别） public class ConstructorDemo { public static void main(String[] args){ try { Class&lt;?&gt; c = Class.forName(&quot;com.demo.moutain.reflectdemo.Person&quot;); //方式一：获得所有公有的构造方法 System.out.println(&quot;获取所有的公共类型的构造方法&quot;); Constructor[] constructors = c.getConstructors(); for(int i = 0 ;i&lt;constructors.length;i++){ System.out.println(constructors[i].toGenericString()); } //方式二：获得指定参数类型的共有的构造方法 System.out.println(&quot;获取指定类型的构造方法&quot;); Constructor constructor = c.getConstructor(new Class[]{String.class,int.class}); System.out.println(constructor.toGenericString()); //方式三：获取所有类型的构造方法，不限制级别 System.out.println(&quot;方式三：获取所有类型的构造方法，不限制级别&quot;); Constructor[] cons = c.getDeclaredConstructors(); for(int i =0;i&lt;cons.length;i++){ System.out.println(cons[i].toGenericString()); } //方式四：获取指定参数类型的构造方法，不限制级别 System.out.println(&quot;获取指定类型的构造方法，不限制级别&quot;); Constructor con = c.getDeclaredConstructor(new Class[]{int.class}); System.out.println(con.toGenericString()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } } } 注意：获取指定参数的构造方法的时候，如果获取一个参数的构造方法时可以传null，也可以传一个空的Class[],但是不能传new Class[]{null}。 获取方法时同样注意。 动态实例化一个对象 获取一个类。 获取这个类的构造方法。 利用获取到的构造方法，动态实例化这个对象。 public class DynamicInstanceDemo { public static void main(String[] args){ Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Person&quot;); Constructor constructor = c.getConstructor(new Class[]{String.class,int.class}); Person p = (Person) constructor.newInstance(&quot;老王&quot;,60); System.out.println(p.toString()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } 结语动态实例化对象可以使用在依赖注入中，也就是我重新看反射的原因。java反射（reflection）详解就先写到这儿。如果文中有错误和不恰当的地方，欢迎留言探讨。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebView中页面的调试环境搭建]]></title>
      <url>%2F2016%2F11%2F29%2FWebView%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[Html页面在WebView中调试的环境搭建准备工作 windows系统 Oracle VM VirtualBox（使用Genymotion所需的环境） Genymotion（Android模拟器） Charles(抓包工具) Chrome浏览器开始搭建 如果你的处理器已经打开支持虚拟化技术的选项，则继续向下进行第二个步骤。如果没有打开，则按照步骤打开处理器的虚拟化技术支持选项，否则无法正常运行Genymotion。这里以联想电脑的ThinkPad为例，其他型号电脑请自行百度。 保存现在电脑上正在操作的文档，并且重启。 当进入开机自检阶段（屏幕显示Lenovo Logo）的时候快速点击F2，进入BIOS设置界面。截图如下：（开机自检页面）(BIOS设置页面）（BIOS设置页面） 进入Virtualization选项并且将其设置为true即可。 安装Oracle VM VirtualBox 如果已经安装过Oracle VM VirtualBox，请直接跳到下一步。 如果没有安装，打开安装文件直接安装即可，安装路径请随意但是不要有中文（切记）。 安装完打开软件。（Oracle VM VirtualBox打开截图） 选择管理–&gt; 导入虚拟电脑 选择安装包里面的Android虚拟机，按照提示导入完成即可。 运行导入的虚拟机。 安装Genymotion 解压安装包中的Genymotion，然后找到Genymotion.exe,这时候就发现了导入到Oracle VM VirtualBox中的虚拟机。 这时候要进行一个网络代理设置：（Genymotion网络代理设置截图）设置这个代理是为了让Charles能够抓到模拟器发出的请求。 设置完代理以后就可以直接运行模拟器了 运行模拟器以后，需要将Genymotion的Wifi设置上网代理，具体修改方法就是进入模拟器的设置页面–&gt; 打开无线网络设置（Wifi设置）–&gt; 找到连接的无线网络（Wired network）并且长按–&gt; 选择Modify netWork –&gt; 选中Show advanced options 参数按照下方截图来填就可以了，注意端口号要和在Oracle VM VirtualBox中设置的端口号一致。 wifi代理设置截图：（wifi网络代理设置截图）设置这个代理是为了让Charles能够抓到模拟器发出的请求。 打开Chrome，在地址栏输入Chrome://inspect。现在应该能够找到你的设备。 为了让Charles能够抓到Chrome的请求，为Chrome安装Proxy SwitchyOmega插件（改插件在安装包里面有），在Chrome中的扩展程序页面可直接拖进安装。 安装完插件以后新增一种情景模式： 对新增的情景模式进行设置： 保存修改后，当使用Charles调试时选择这个情景模式就可以了。 Charles 安装 打开安装包中的Charles文件夹，打开Charles安装包，进行安装。安装完成后会发现是30天的试用版，在Charles文件夹中还有一个Charles.jar，将它复制到安装所在位置的lib文件夹下，替换掉原来的即可。重新打开会发现…。 设置Charles监听的端口： 同样将端口设置为和模拟器的一致。 设置完端口以后，打开Genymotion，访问一个网页，会发现请求已经被Charles抓到了。找到你需要调试的域名，右击–&gt; 选择MappingLocal 按照截图设置 host设置为要拦截的域名（关键字），port就是默认的80即可。localpath就选择你本地的项目所在路径。 经过以上五步的搭建，你就会发现，你在WebView（安卓模拟器）中请求原来的路径时，已经被charles拦截到本地的项目上了。但是这时候没有控制台啊。怎么调试呢？ 打开Chrome进入Chrome://inspect页面，看到你的请求路径，然后点击inspect，就能打开控制台了，但是这一步第一次打开的时候得科学上网。注意：第一次打开一定要科学上网，但是以后打开就不用了，否则会很慢（卡顿）。结语经过上面的搭建，你就可以发现，在webview中的页面可以直接在pc上调试了。附：本教程所需安装包 密码：zy7t下载后可以实现离线安装。如有问题，可以留言。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HelloWorld]]></title>
      <url>%2F2016%2F11%2F29%2FHelloWorld%2F</url>
      <content type="text"><![CDATA[开题 这是我的第一篇博客，我搭建好博客平台已经一个月了，这一个月我的博客上一直是搭建博客的时候的HelloWorld。没有写博客并不是忙，其实是懒了。年轻人是不能够懒的。看似有大把的时间。但是一旦懒了以后，就会发现时间已经偷偷溜走了。所以说，接下来的时间里，无论多忙。我都会保证每周都更新一篇博客。我知道访问量不多，但是就算读者只有我自己，我也会坚持啊。 我的博客主要是一个技术博客我会在博客中分享一些技术贴。总结在开发中遇到的问题，希望和大家一起探讨吧。同时在分享技术之余，也会写一些文。毕竟，会写文是现在的小鲜肉必备的素能之一。不管咋说，改变原来慵懒的生活节奏。做一个积极向上的小鲜肉。有些人才20多岁，但是心态像5、60岁的人（心态不是经验）。有些人5、60岁了，但是心态像一个年轻人。保持一颗年轻的心是很不容易的。希望自己永远年轻吧。 关于未来技术是我的爱好，但是上班不是我的梦想。我有一颗向往自由的心。再给自己一段时间。如果没有大的进展，就去追随自己的梦想。嗯，就这样了。 最后，祝好。]]></content>
    </entry>

    
  
  
</search>
