<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F07%2F27%2Fjenkins%2Bgradle%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%89%93%E5%8C%85%2F</url>
      <content type="text"><![CDATA[title: jenkins+gradle持续集成打包date: 2017-07-27 14:05:24tags: Android categories: Android参考博客：http://www.jianshu.com/p/38b2e17ced73http://blog.csdn.net/mabeijianxi/article/details/52680283 遇到的问题: 插件在jenkins中找不到。 离线安装插件：下载地址离线下载网站 插件管理–&gt;高级–&gt;上传安装。（插件之间会有依赖关系，如果报错就先安装依赖的插件）。 ANDROID_HOME环境变量配置: 系统管理–&gt;系统设置–&gt;全局属性，添加一个即可 在gradle编译之前确定jenkins服务器中的workspace代码路径正确。 如果遇到Waiting to acquire shared lock on daemon addresses registry.输出信息，可能是服务器上的glibc版本问题。参考https://www.v2ex.com/t/351402这篇博文解决。 博文中获取蒲公英的Result是使用正则匹配输出log中的字符，但是正则表达式写错了，应该是笔误，将中文的（）换成英文的()。 在linux中引用变量和在windows中引用是不同的，一个是使用%VALUE%，一个是使用${VALUE}。需要注意一下，否则取值可能会有问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css学习笔记]]></title>
      <url>%2F2017%2F06%2F14%2F0607CSS%2F</url>
      <content type="text"><![CDATA[一、CSS介绍： CSS：层叠样式表。以html文档为基础。 要考虑CSS样式的兼容性，CSS3，IE9以上版本支持。CSS2.0+能兼容IE6以上的版本。二、编写CSS样式： html标签的默认样式是能够通过浏览器的改变的，所以说标签的样式也叫作浏览器样式（默认样式）。 引入CSS的方式： 行内设置（设置style属性来实现控制标签样式的效果），style属性中可多条的CSS样式。 内嵌样式（嵌入样式、内部样式）：在head标签当中嵌入style标签（style中的type属性的默认值就是type=”text/css”）。 外部样式（外联样式）：通过link标签来实现。引入一个CSS文件来管理CSS样式。 补充：@import导入样式就是相当于内嵌样式只不过是通过@import来导入一个css文件，也可以使用@import标签将一个css文件引入到另一个css文件。 这样使用CSS样式会导致：1、css文件不能并行下载。2、导入样式的书写必须写在所有的css样式规则之前（执行的先后顺序）。导入css使用非常不便，不推荐使用。 css的简单属性： width、height、color、background-color、font-size等。 三、css选择器综述： 所有标签选择器*{}：通配符选择器的优先级高于继承的样式。通常使用通配符选择器清除html标签的默认样式（margin padding）。 标签选择器： p{} div{} id选择器： #head{}，id选择器使用’#’，帮助我们调整当前页面唯一id值的标签样式 。id在一个页面中是唯一的。 补充：id选择器的命名规范： 只允许出现字母（大小写均可，严格区分大小写）、下划线、数字。id=”p1”和id=”P1”不冲突。 只允许以字母开头。 命名没有长度限制，但是不建议太长。 不允许出现标签名（约定俗成，不是硬性规定）。 类选择器 .head{}：类选择器就是在一个html文档中选出需要统一样式的一组不相关的标签用同一类名命名，然后同一修改其样式。同一个标签可以属于多个类，类名之间用空格隔开。 补充：class的属性值可以在同一页面中出现多次，但是id的属性值只能在同一页面中出现一次。建议多使用class，因为便于管理，如果确实能够确定当前页面中这个标签只会出现一次（比如logo），就可以是用id选择器，如果不能保证就使用类选择器。 层级选择器 分组选择器 属性选择器：就是选择出有某个或者某些属性的某个标签。标签名[id]，比方说：h1[id][class]{}，选择出有id属性和class属性的h1标签来实现对应的css样式。也可以指定某个属性的值的标签，比方说指定type为text的输入框input[type=”text”]。 子元素（子代）选择器：使用”&gt;”连接标签，只选择下面一级的对应的标签。并不是所有的标签嵌套就意味着多级，span的嵌套不算是子集，只有容器嵌套才能算是子集。 相邻兄弟选择器 伪类选择器：&lt;pre&gt;&lt;code&gt; /*未被访问过的超链接的css样式*/ a:link { color: red; } /*访问过的超链接的css样式*/ a:visited { color: purple; } /*悬停的时候执行的css样式*/ a:hover { background-color: silver; color: white; } /*点击时展示的css样式*/ a:active { color: yellow; } /*love hate原则 必须要注意设置伪类的顺序，不然因为层叠的原因会出现效果混乱*/ /*获得焦点的时候展示的css样式 */ :focus { font-size: 20px; } &lt;/code&gt;&lt;/pre&gt; 伪元素选择器： /* 伪元素是指的内容css样式的变化 */ /* artcle-txt类中的第一行显示该css样式。 */ .artcle-txt:first-line { color: red; } /* artcle-txt类中的第一个字显示该css样式 */ .artcle-txt:first-letter { color: green; } /* 是第一个子标签的span标签显示这个css样式 */ span:first-child { color: silver; } /* 只有before和after伪元素才有content，并且content是加在行内。如果再加上display属性并且设置为block，这样就将content设置成了块状元素 */ .wrap:before,.wrap:after { content: "----------------"; display: block; } 复合选择器：标签和class一起定义，只有符合class的对应的标签才能实现对应的css样式。注意是一个”&amp;&amp;”的关系。标签名在前，类名在后，没有空格。 后代选择器：（实际上是从右向左进行匹配的）class和标签一起定义，指这个class下面的对应的标签实现对应的css样式。也是一个”&amp;&amp;”的关系。class在前，标签名在后，中间空格隔开。 并集选择器：多个选择器用”,”隔开。 四、css的层叠性和继承性： 层叠性是指在样式的优先级相同的情况下才会生效。 层叠性：就是css是分层的，后面设置的样式会覆盖前面设置的样式。 继承性：子类标签会受父类容器样式的影响。继承的样式是文字相关的样式。但是容器相关的样式不会被继承。一般会在body中，给子类标签设置同一的文字样式。 五、css的优先级：1. 由高到低：行内样式-&gt;id选择器-&gt;类选择器-&gt;标签选择器。 2. 继承的css样式优先级要大于标签默认的css样式。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;12css优先级案例&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* div继承的css样式的优先级要高于标签默认的css样式的优先级 */ body { color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;div&gt;这是一个div&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3. 通配符（*）的css样式要比继承的css样式的优先级要高。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;12css优先级案例&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* div继承的css样式的优先级要高于标签默认的css样式的优先级 */ body { color: red; } /* 通配符的css样式的优先级要比继承的css样式的优先级要高 */ * { color: green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;div&gt;这是一个div&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 4. 标签选择器的css样式的优先级要高于通配符选择器的css样式。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;12css优先级案例&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* div继承的css样式的优先级要高于标签默认的css样式的优先级 */ body { color: red; } /* 通配符的css样式的优先级要比继承的css样式的优先级要高 */ * { color: green; } /* 标签选择器的css样式优先级高于通配符选择器的css样式 */ h1 { color: orange; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;div&gt;这是一个div&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 5. 类选择器的css样式的优先级要高于标签选择器的css样式 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;12css优先级案例&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* div继承的css样式的优先级要高于标签默认的css样式的优先级 */ body { color: red; } /* 通配符的css样式的优先级要比继承的css样式的优先级要高 */ * { color: green; } /* 标签选择器的css样式优先级高于通配符选择器的css样式的优先级 */ h1 { color: orange; } /* 类选择器的css样式的优先级高于标签选择器的css样式的优先级 */ .h1-txt { color: purple; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;h1-txt&quot;&gt;这是一个标题&lt;/h1&gt; &lt;div&gt;这是一个div&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 6. id选择器的css样式优先级要高于类选择器的css样式的优先级 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;12css优先级案例&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* div继承的css样式的优先级要高于标签默认的css样式的优先级 */ body { color: red; } /* 通配符的css样式的优先级要比继承的css样式的优先级要高 */ * { color: green; } /* 标签选择器的css样式优先级高于通配符选择器的css样式的优先级 */ h1 { color: orange; } /* 类选择器的css样式的优先级高于标签选择器的css样式的优先级 */ .h1-txt { color: purple; } /*id选择器的css样式的优先级要高于类选择器的css样式的优先级 */ #h1-wrap { color: silver; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;h1-txt&quot; id=&quot;h1-wrap&quot;&gt;这是一个标题&lt;/h1&gt; &lt;div&gt;这是一个div&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 7. 行内样式的优先级要高于id选择器的优先级 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;12css优先级案例&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* div继承的css样式的优先级要高于标签默认的css样式的优先级 */ body { color: red; } /* 通配符的css样式的优先级要比继承的css样式的优先级要高 */ * { color: green; } /* 标签选择器的css样式优先级高于通配符选择器的css样式的优先级 */ h1 { color: orange; } /* 类选择器的css样式的优先级高于标签选择器的css样式的优先级 */ .h1-txt { color: purple; } /*id选择器的css样式的优先级要高于类选择器的css样式的优先级 */ #h1-wrap { color: silver; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;h1-txt&quot; id=&quot;h1-wrap&quot; style=&quot;color:pink&quot;&gt;这是一个标题&lt;/h1&gt; &lt;div&gt;这是一个div&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 复合选择器和上面的选择器优先级一致，一个一个的比较就好。 六、css的单位各文字排版 标签的显示属性：display： display可以来设置块级元素变成一个行内元素（inline），同理display属性可以将行内元素变成一个块级元素（block）。display属性设置为none的话就是将该标签删除（不显示、不占位）。 补充：还有一个属性：visibility:这个属性控制css的隐藏和显示。如果设置为隐藏，控件为隐藏，但是占位还在。 行内元素、行内块元素、块级元素之间的区别： 行内元素不能设置宽高，行内块元素、块级元素能够设置宽高。 行内元素只有左右边距没有上下边距，行内块元素和块级元素有上下左右边距。 行内元素和行内块元素不独占一行，块级元素独占一行。 css颜色表示： RGB颜色表示法：p {color:rgb(255,255,0)}或者p{color:(100%,100%,0)}。（使用0~255之间的值来表示，或者是使用百分比来表示）。 十六进制的颜色值来表示。 css的长度单位： 绝对长度单位：cm、mm、in、pc等等。 相对长度单位：px、em（相当于当前字体的大小）。开发的时候以px为主。 font-size：设置字体字号的大小。 font-family：设置字体的样式。 注意： 为了保证网页显示效果的兼容性一般会设置多个字体，多个字体之间使用英文逗号隔开，优先级顺序是从左往右适配。 中文字体需要加英文状态下的引号，英文字体不需要引号，当需要设置英文字体时，英文字体名必须在中文字体名之前。 如果字体名中包含空格、#、$等符号，则该字体名必须加英文状态下的单引号或者双引号。 尽量使用默认字体，保证在任何用户的浏览器中都能正常显示。 为了保证兼容性，尽量使用utf-8编码来表示中文字符。可以在浏览器控制台中使用escape()函数来转化。转化完成后将‘%’换成‘/’即可。 为了更加保证兼容性可以选择衬线体或者非衬线体作为字体最后的一个选择。衬线体和非衬线体是指一种字体的样式。如果前面指定的字体没有找到，浏览器会在当前电脑中任意找一种衬线体或者非衬线体来显示。 font-weight：字体加粗有继承性，属性值：normal、bold、bolder、lighter、100~900（100的整数倍）。400是normal、700是bold。 font-style：设置字体的显示风格（斜体、正常、倾斜）。属性值有normal（正常显示）、italic（浏览器会使用斜体的字体显示，如果该字体没有斜体，则正常显示）、oblique（浏览器让字体倾斜显示）。 七、盒模型： 盒模型的前提是DTD声明。不然可能出现非标准盒模型的展示。 组成：内容区域、内边距、边框、外边距。 网页就是多个盒子嵌套的结果。 内边距出现在内容区域的周围，当给元素添加背景色和背景图片时，背景色或者背景图像也就显示在内边距区域内。如果给元素定义边框，边框会出现在内边距和外边距之间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[html学习笔记]]></title>
      <url>%2F2017%2F06%2F14%2F0524HTML%2F</url>
      <content type="text"><![CDATA[一、介绍： 浏览器访问服务器的过程：浏览器接受用户操作–&gt;浏览器封装HTTP请求–&gt;连接服务器：DNS解析–&gt;发送请求Request–&gt;服务器接受请求–&gt;处理请求–&gt;返回响应报文–&gt;浏览器接收响应报文–&gt;渲染页面呈现。 DNS：Domain Name System：域名解析系统。先访问DNS服务器来获取域名对应的ip，然后再根据ip来访问服务器。 后缀名的问题：htm是为了兼容DOS系统，开发过程中后缀名使用htm或者html都可以。 二、标签： doctype：声明html的版本。 head标签是给浏览器读取的一些设置： meta标签是告诉浏览器当前的编码格式。当浏览器读取的编码格式和声明的编码格式不一致的时候，会出现乱码。 title：设置浏览器标题栏中的显示内容。 Link：引入CSS样式、DNS预解析（缓存网站的ip地址）、引入网站icon的标签三、URL协议： scheme://host.domain:port/path/filename scheme：定义因特网服务的类型，常见的http、https、ftp。 host：定义域主机（http默认的主机是www）。 domain：定义因特网域名,比如w3school.com.cn。 port：定义主机上的端口号（http默认的端口号是80）。 path：定义服务器上的路径（如果省略，则文档必须位于网站的根目录内）。 url编码： 避免网址（url地址）在全球都能够显示并访问，将不是ASCII编码的字符编码成%ASCII的形式。urlencode（编码）、urldecode（解码）。 四、相对路径和绝对路径： DOS命令常用操作： cls ：清屏。 Tab键可以自动补齐命令。 cd demo ：进入Demo文件夹。 cd ../ ：返回上级目录。 cd ../../ ：返回上两级目录。 dir：展示当前目录中的文件和文件夹。 md：创建目录。 相对路径和绝对路径的区别： 相对路径： 是相对当前位置目标文件或者目录的位置。 ./当前目录下； ../当前目录的父级目录下； ../../当前目录的父级的父级目录下。 绝对路径： 是指定盘符和位置。五、图片标签的使用&lt;img src=”” title=”图片的标题” alt=”当图片不显示的时候，会显示alt属性文本”&gt;src：图片的地址alt：当图片不显示的时候，会显示alt属性文本title：对网站seo有很大的影响，当鼠标移上去的时候，图片显示的tip提示文本内容。 常见的图片格式： .gif：非常小、兼容性好、支持透明、支持动画、但是只能处理255种颜色。色彩太多不行。（logo） .jpg（JPEG）：有损压缩格式，文件体积小，便于在网络上传输、但是压缩成jpg格式以后容易失真。（广告banner图、海报、照片） .png：包括png-8和真色彩png。文件体积比gif更小、支持透明、但是会有兼容性的问题（ie6处理png-24会出现灰色的问题）。 六、标签： heading标签（h1-h6）补充： DTD：文档类型定义。是html5的声明。 heading标签并不是为了页面样式的，而是为了网站的SEO优化，如果heading使用不好，会导致网站的主题不明确。样式在CSS中都可以调整。 一般一个页面中只有一个h1标签，可以有多个h2标签。有标题就使用heading标签，没有标题就不使用heading标签（注意语义化）。如果heading标签滥用会被搜索引擎识别为作弊。 h1-h6标签对于当前文档的重要性一次降低。 p标签（段落标签）特点：独占一行或多行。 单标签： 水平线标签（&lt;hr/&gt;）、换行标签（&lt;br/&gt;）。 在h5的标准中，单标签是不需要写”/“的，h5之前的版本是强制需要的。 html文档空白合并：在html文档中，文字之间的空格会进行合并，多个空格或者是换行会合并成一个空格。 如果想让html文档换行的话，就得使用标签。如果想加多个空格就使用&nbsp;,这样html文档会识别为空格。 其他标签： &lt;span&gt;&lt;/span&gt;：文本节标签，对某几个文本进行样式修改。 &lt;em&gt;&lt;/em&gt;：强调标签。局部文本的加强语气或者文本强调。加上以后文本会变成斜体，但是em不是用来对文本样式的修改，主要是包裹文档中的中心文本，进行着重强调，有利于网站的SEO优化。 &lt;i&gt;&lt;/i&gt;：定义文本成为斜体，纯粹对网页文档的样式进行修改。没有语义化功能，不推荐使用，样式的修改推荐使用CSS进行修改。 &lt;strong&gt;&lt;/strong&gt;：定义加重语气，对整个文档或者段落进行加重语气。没有语义化作用。注意与&lt;em&gt;&lt;/em&gt;的区别：整体与部分。 &lt;b&gt;&lt;/b&gt;:加粗标签，单纯样式的改变。 &lt;sub&gt;&lt;/sub&gt;：下标文字 &lt;sup&gt;&lt;/sup&gt;：上标文字 &lt;del&gt;&lt;/del&gt;：添加删除线 七、超链接和图片： &lt;a&gt;&lt;/a&gt;：超链接标签 herf：目标页面的地址 target：指定在哪个窗口打开目标页面（_blank，_self），_self表示在当前页签打开目标链接，_blank表示在新窗口打开目标链接。如果超链接的目标路径没有确定或者没有，就写一个#。 锚点链接：跳转到某个span区域并且该区域放在页面的最上方（如果当前页面够长）。&lt;a href=’#demoplace’&gt;跳转到当前页面的id为demoplace的span区域。&lt;span id=’demoplace’&gt;跳转到当前区域&lt;/span&gt;。注意：超链接不仅仅可以嵌套文本，还可以嵌套表格和图片。 八、高级标签 列表标签 无序列表：&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt;：ul标签之间不嵌套其他标签，但是li之间可以嵌套其他任何标签。 有序列表：&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/li&gt;：ul标签之间不嵌套其他标签，但是li之间可以嵌套其他任何标签。 自定义列表：&lt;dl&gt;&lt;/dl&gt;： &lt;dt&gt;&lt;/dt&gt;：列表的title，里面包裹文本标签（等） &lt;dd&gt;&lt;/dd&gt;：列表项 列表嵌套：&lt;table&gt;&lt;/table&gt;：表格标签。&lt;tr&gt;&lt;/tr&gt;：表示行。&lt;td&gt;&lt;/td&gt;：表示列。&lt;thead&gt;&lt;/thead&gt;：表格中的表头，包裹&lt;tr&gt;&lt;td&gt;标签，&lt;th&gt;标签包裹不同的表头,使用&lt;tr&gt;（行头部）或者&lt;td&gt;(列头部)标签包裹。&lt;tbody&gt;&lt;/tbody&gt;：表格中的单元格，就是将&lt;tr&gt;&lt;td&gt;标签使用&lt;tbody&gt;标签包裹。 列表单元格的合并：如果跨行合并就在&lt;tr&gt;标签中使用rowspan=num，如果跨列合并就在&lt;td&gt;标签中使用colspan=num。 节标签：&lt;div&gt;和&lt;span&gt;标签。&lt;div&gt;：块状标签，独占一行。&lt;span&gt;：行内标签，不会独占一行，与行内的其他标签共占一行。&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;dl&gt;、&lt;li&gt;、&lt;dt&gt;、h1~h6：这些标签都是块级标签。&lt;span&gt;&lt;strong&gt;&lt;em&gt;等：文本相关的标签都是行内标签。 内联框架标签（不建议使用，使用div替代）： iframe标签（这是一个行内标签），能够在当前html页面中完全显示目标地址的页面。 meta标签：可是设置关键字（SEO优化）。 link标签：引入css base标签：可以让当前页面的所有的a标签都有相同的属性。 pre标签：保留原来的文本格式（空格、换行） 九、表单： 在html中一个完整的表单通常由表单控件、提示信息、表单域三个部分构成。 组合表单的标题：formset lenged是定义表单的头部。 radio标签可以使用label标签来实现点击文字选中某个选项 label标签可以帮助某个控件获取焦点。 select标签：可以表示下拉列表和普通的列表。option可以定义select的选项。 textarea标签：输入大量文本的时候使用。可以设置行数rows和列数cols。 十、字符实体： 实现在html中页面中显示html的代码。相当于java中的转义字符。 常用：&copy;：版权符号，&reg;：注册商标 html总结： 1. html：页面结构。 2. css：页面的样式。 3. JavaScript：页面的交互效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在view渲染出来之前获取view的宽高]]></title>
      <url>%2F2017%2F04%2F07%2Fget%20view%20width%20and%20height%2F</url>
      <content type="text"><![CDATA[获取view的宽高。 在学习自定义控件的时候需要在view渲染出来之前获取到该view的宽高，如果直接获取宽高会是0，所以在网上搜到了以下几个方法。用博客记录下来。 普通的做法LayoutInflater.from(context).inflate(R.layout.float_window_small, this); View view = findViewById(R.id.float_window_small); viewHeight = view.getWidth(); viewWidth = view.getHeight(); System.out.println(&quot;measure width=&quot; + viewWidth + &quot; height=&quot; + viewHeight); 在view渲染出来的情况下，这种方法是能够获取到宽高的。但是在onCreate()、onStrart()、onResume()方法中会返回0，这是应为当前activity所代表的界面还没显示出来没有添加到WindowPhone的DecorView上或要获取的view没有被添加到DecorView上或者该View的visibility属性为gone 或者该view的width或height真的为0 所以只有上述条件都不成立时才能得到非0的width和height。如果要使用这种方法获取view的宽高建议： 在回调（点击事件、触摸事件、焦点事件）中测量。要保证获取宽高的view是在setContentView时设进去的View或它的子View。 在activity被显示出来时即添加到了DecorView上时获取宽和高如onWindowFocusChanged()回调方法。要保证获取宽高的view是在setContentView时设进去的View或它的子View。 @Override public void onWindowFocusChanged(boolean hasFocus) { View iv1 = findViewById(R.id.iv1); View iv2=findViewById(R.id.iv2); String msg1=&quot;iv1&apos; width:&quot;+iv1.getWidth()+&quot; height:&quot;+iv1.getHeight()+&quot; measuredWidth:&quot;+iv1.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv1.getMeasuredHeight(); String msg2=&quot;iv2&apos; width:&quot;+iv2.getWidth()+&quot; height:&quot;+iv2.getHeight()+&quot; measuredWidth:&quot;+iv2.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv2.getMeasuredHeight(); i(&quot;onWindowFocusChanged() &quot;+msg1); i(&quot;onWindowFocusChanged() &quot;+msg2); super.onWindowFocusChanged(hasFocus); } 在onResume方法最后开线程300毫秒左右后获取宽和高 因为onResume执行完后300毫秒后 界面就显示出来了。 view.postDelayed(new Runnable() { @Override public void run() { View iv1 = findViewById(R.id.iv1); View iv2=findViewById(R.id.iv2); String msg1=&quot;iv1&apos; width:&quot;+iv1.getWidth()+&quot; height:&quot;+iv1.getHeight()+&quot; measuredWidth:&quot;+iv1.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv1.getMeasuredHeight(); String msg2=&quot;iv2&apos; width:&quot;+iv2.getWidth()+&quot; height:&quot;+iv2.getHeight()+&quot; measuredWidth:&quot;+iv2.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv2.getMeasuredHeight(); i(&quot;onWindowFocusChanged() &quot;+msg1); i(&quot;onWindowFocusChanged() &quot;+msg2); } }, 300); 在onCreate()或onResume()等方法中监听视图树来获取，获取完后记得让view删除该回调。 view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { view.postDelayed(new Runnable() { @Override public void run() { View iv1 = findViewById(R.id.iv1); View iv2=findViewById(R.id.iv2); String msg1=&quot;iv1&apos; width:&quot;+iv1.getWidth()+&quot; height:&quot;+iv1.getHeight()+&quot; measuredWidth:&quot;+iv1.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv1.getMeasuredHeight(); String msg2=&quot;iv2&apos; width:&quot;+iv2.getWidth()+&quot; height:&quot;+iv2.getHeight()+&quot; measuredWidth:&quot;+iv2.getMeasuredWidth()+&quot;measuredHeight:&quot;+iv2.getMeasuredHeight(); i(&quot;onWindowFocusChanged() &quot;+msg1); i(&quot;onWindowFocusChanged() &quot;+msg2); } }, 300); } }); 取消视图树监听 if(Build.VERSION.SDK_INT&gt;=16){ tv.getViewTreeObserver().removeOnGlobalLayoutListener(this); }else{ tv.getViewTreeObserver().removeGlobalOnLayoutListener(this); } 渲染之前获取的方法：LayoutInflater.from(context).inflate(R.layout.float_window_small, this); View view = findViewById(R.id.float_window_small); int w = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); int h = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); view.measure(w, h); viewHeight = view.getMeasuredHeight(); viewWidth = view.getMeasuredWidth(); System.out.println(&quot;measure width=&quot; + viewWidth + &quot; height=&quot; + viewHeight);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java反射（Reflection）详解]]></title>
      <url>%2F2017%2F03%2F13%2F%E5%8F%8D%E5%B0%84_3%2F</url>
      <content type="text"><![CDATA[接上篇上一篇博客介绍： 通过反射获取一个类的属性 通过反射获取一个类的方法并且调用该方法 通过反射获取一个类的接口 通过反射获取一个类的父类 Array工具类对数组的操作 补充通过反射对一个类中的私有属性和方法进行访问 在本篇博客中我说一下动态代理的实现。 动态代理动态代理实际上是代理模式的实现代理模式： 代理模式是java常用的设计模式，他的特征是代理类与委托类实现同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类、以及事后处理消息（或者进行相应的操作）。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对相关联，代理类的对象并不真正实现服务，而是通过调用委托类的相关方法，来提供特定的服务。 jdk动态代理中包含了reflect包下的一个类和一个接口：InvocationHandler接口： public interface InvocationHandler(){ public Object invoke(Object proxy,Method method,Object[] args) throws Throwable; } 参数说明： Object proxy 指被代理的对象 Method method 指要调用的方法 Object[] args 方法调用时所需要的参数 Proxy类：Proxy类是专门完成代理的操作类，可以通过此类为一个或者多个接口动态的生成实现类，此类提供了如下的操作方法： public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvokcationHandler h) throws IllegalArgumentException{ } 参数说明： ClassLoader：类加载器 Class&lt;?&gt;[] interfaces ：得到全部的接口 InvokcationHandler h ：得到InvokcationHandler接口的子类实例类加载器：在Proxy类中的newProxyInstance()方法中需要一个ClassLoader类的实例，ClassLoader对应的是类加载器，在java中主要有一下三种类加载器: Booststrap ClassLoader：负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类。 Extendsion ClassLoader：负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包。 App ClassLoader：负责加载classpath中指定的jar包及目录中class。 Custom ClassLoader：属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader 加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 （Tinker就是根据这个原理实现的）对加载器的描述来自这篇博文，原文讲解了java中一个类加载的过程个人觉得说的很透彻结合代码来说一下动态代理：写一个接口： public interface Dinner { //吃饭的方法 public abstract void eat(); }写一个委托类（实现了上述接口）： public class EatDinner implements Dinner { @Override public void eat() { System.out.println(&quot;吃饭&quot;); } } 写一个代理类实现InvocationHandler（）接口： public class EatDinnerProxy implements InvocationHandler { private Object originalObject; /** * 构造方法，构造目标对象 * @param target 委托类的对象 */ public EatDinnerProxy(Object target){ this.originalObject = target; } /** * 执行目标对象的方法 * @param proxy * @param method * @param args * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = null; eatBefore(); result = method.invoke(originalObject,args); eatAfter(); return result; } private void eatAfter() { System.out.println(&quot;吃饭之后&quot;); } private void eatBefore() { System.out.println(&quot;吃饭之前&quot;); } public Object getProxy(){ return Proxy.newProxyInstance(originalObject.getClass().getClassLoader(),originalObject.getClass().getInterfaces(),this); } } 测试类： public class DynamicProxyTest { public static void main(String[] args){ EatDinner eatDinner = new EatDinner(); Dinner dinner = (Dinner) new EatDinnerProxy(eatDinner).getProxy(); dinner.eat(); } } 到这里就实现了一个动态代理，但是对动态代理的原理还是没有彻底搞明白。这篇文章可能会有帮助 。 总结回顾反射的目的就是为了学习Annotation相关的额知识，所以接下来的博客我会重点找Annotation相关的资料来看，争取吃透Annotation在android中的使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java反射（reflection）详解]]></title>
      <url>%2F2017%2F03%2F13%2F%E5%8F%8D%E5%B0%84_2%2F</url>
      <content type="text"><![CDATA[接上篇上一篇博客介绍了反射的基本概念： 运行时获取到一个Class 获取该类的构造方法 动态实例化这个类 这篇博客说一下怎样通过反射获取类的属性、方法、接口、该类的父类、以及通过反射实现Array工具类对数组的操作 先贴上这篇文章中用到的bean类 public class Person { private String name; private int age; public boolean isSomking; public Person(){} public Person(String name,int age){ this.name = name; this.age = age; } Person(String name){ this.name = name; } private Person(int age){ this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String toString() { return &quot;姓名：&quot;+this.getName()+&quot;,年龄：&quot;+this.getAge(); } } public class Animal { public String name; private int age; boolean isLand; public void eat(){ System.out.println(&quot;动物在吃饭&quot;); } private void sleep(){ System.out.println(&quot;动物在睡觉&quot;); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public boolean isLand() { return isLand; } public void setLand(boolean land) { isLand = land; } } public class Cat extends Animal implements View.OnClickListener,Serializable{ public void run(String name,int age){ System.out.println(&quot;一只&quot; + age + &quot;岁的叫&quot; + name +&quot;的猫在跑&quot;); } public void run(){ System.out.println(&quot;猫在跑&quot;); } private void jump(){ System.out.println(&quot;猫在跳&quot;); } public static void main (String[] args){ Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Cat&quot;); Cat cat = (Cat) c.newInstance(); Method method = c.getDeclaredMethod(&quot;jump&quot;,null); method.invoke(cat,null); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } @Override public void onClick(View v) { } } 属性（Field）通过反射获取属性信息和获取构造方法相似，不赘述。public class FieldDemo { public static void main(String[] args) { Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Person&quot;); //方法一：获取所有公有类型的属性 System.out.println(&quot;获取所有的公有属性：&quot;); Field[] fields = c.getFields(); for (int i = 0; i &lt; fields.length; i++) { System.out.println(fields[i]); } //方法二：获取指定的公有属性 System.out.println(&quot;获取指定的公有属性：&quot;); Field field = c.getField(&quot;isSomking&quot;); System.out.println(field.toGenericString()); //方法三：获取所有的属性（不限制级别） System.out.println(&quot;获取所有的属性：&quot;); Field[] privateFields = c.getDeclaredFields(); for (int i = 0; i &lt; privateFields.length; i++) { System.out.println(privateFields[i]); } //方法四：获取指定的属性（不限制级别），但是这儿获取的私有属性是不能被访问的。 System.out.println(&quot;获取指定的属性：&quot;); Field privateField = c.getDeclaredField(&quot;age&quot;); System.out.println(privateField); } catch (ClassNotFoundException ex) { ex.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } } } 方法（Method）通过反射获取方法和获取构造方法相似，不赘述。public class MethodDemo { public static void main(String[] args) { Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Cat&quot;); //获取类中所有的公有方法（该方法会将父类的公有方法一并得出） System.out.println(&quot;获取类中所有的公有方法&quot;); Method[] methods = c.getMethods(); for(int i = 0;i&lt;methods.length;i++){ System.out.println(methods[i]); } //获取类中指定参数的公有的方法 System.out.println(&quot;获取类中指定参数的公有方法&quot;); Method method = c.getMethod(&quot;run&quot;,new Class[]{String.class,int.class}); System.out.println(method.toGenericString()); //获取所有的方法（不限制级别）这儿只能获取到本类中的不限制级别方法。 System.out.println(&quot;获取所有的方法（不限制级别）&quot;); Method[] privateMethods = c.getDeclaredMethods(); for(int i = 0;i&lt;privateMethods.length;i++){ System.out.println(privateMethods[i]); } //获取指定参数的方法（不限制级别）如果没有参数注意同上一篇的获取构造方法 System.out.println(&quot;获取指定参数的方法（不限制级别）&quot;); Method privateMethod = c.getDeclaredMethod(&quot;jump&quot;,null); System.out.println(privateMethod.toGenericString()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } } } 通过反射调用Class中的方法（method.invoke()） 首先生成一个Class的对象 获取到你要调用的方法 使用要调用方法的invoke(class,params) 注意：私有方法只能在本类中调用。这儿所说的本类是指方法所在的类。 public class MethodDemo { public static void main(String[] args) { Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Cat&quot;); //获取类中所有的公有方法（该方法会将父类的公有方法一并得出） System.out.println(&quot;获取类中所有的公有方法&quot;); Method[] methods = c.getMethods(); for(int i = 0;i&lt;methods.length;i++){ System.out.println(methods[i]); } //获取类中指定参数的公有的方法 System.out.println(&quot;获取类中指定参数的公有方法&quot;); Method method = c.getMethod(&quot;run&quot;,new Class[]{String.class,int.class}); System.out.println(method.toGenericString()); //获取所有的方法（不限制级别）这儿只能获取到本类中的不限制级别方法。 System.out.println(&quot;获取所有的方法（不限制级别）&quot;); Method[] privateMethods = c.getDeclaredMethods(); for(int i = 0;i&lt;privateMethods.length;i++){ System.out.println(privateMethods[i]); } //获取指定参数的方法（不限制级别）如果没有参数可以传null System.out.println(&quot;获取指定参数的方法（不限制级别）&quot;); Method privateMethod = c.getDeclaredMethod(&quot;jump&quot;,null); System.out.println(privateMethod.toGenericString()); //调用一个Class的方法 注意这儿不能调用类的私有方法，私有方法只能在本类中调用 // Cat cat = (Cat) c.newInstance(); // privateMethod.invoke(cat,null); System.out.println(&quot;通过反射调用class中的方法&quot;); Cat cat = (Cat) c.getConstructor().newInstance(); method.invoke(cat, new Object[]{&quot;小花&quot;,2}); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } 通过反射获取一个类中的接口信息（Interface）首先让Person实现两个接口，然后通过反射获取到该类实现的接口信息 public class InterfaceDemo { public static void main(String[] args){ Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Cat&quot;); Class[] interfaces = c.getInterfaces(); for(int i = 0;i&lt;interfaces.length;i++){ System.out.println(interfaces[i].toString()); } } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 通过反射获取一个类的父类信息（SuperClass）public class SuperClassDemo { public static void main(String[] args){ Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Cat&quot;); Class clazz = c.getSuperclass(); System.out.println(clazz.toString()); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 通过Array来操作数组（Array提供动态的访问或者生成数组的方法）（Array）public class ArrayDemo { public static void main(String[] args) { Person[] persons = new Person[]{ new Person(&quot;路人甲&quot;, 18), new Person(&quot;路人乙&quot;, 19), new Person(&quot;路人丙&quot;, 20) }; Array.set(persons,0,new Person(&quot;修改&quot;,0)); for (int i = 0;i&lt;persons.length;i++){ System.out.println(persons[i]); } System.out.println(Array.getLength(persons)); } } 补充（AccessableObject） 上面说到通过反射获取到类的私有属性和方法的时候无法访问或者调用，于是翻看reflect包下的AccessableObject类，有如下发现。 The AccessibleObject class is the base class for Field, Method and Constructor objects. It provides the ability to flag a reflected object as suppressing default Java language access control checks when it is used. The access checks–for public, default (package) access, protected, and private members–are performed when Fields, Methods or Constructors are used to set or get fields, to invoke methods, or to create and initialize new instances of classes, respectively. 由于英语没有过六级，只能理解大体意思：就是通过反射进行获取属性、构造方法、方法会进行安全检查。但是下面它提供了这样的一个方法： public void setAccessible(boolean flag) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) sm.checkPermission(ACCESS_PERMISSION); setAccessible0(this, flag); } private static void setAccessible0(AccessibleObject obj, boolean flag) throws SecurityException { if (obj instanceof Constructor &amp;&amp; flag == true) { Constructor&lt;?&gt; c = (Constructor&lt;?&gt;)obj; Class&lt;?&gt; clazz = c.getDeclaringClass(); if (clazz == Class.class) { throw new SecurityException(&quot;Can not make a java.lang.Class&quot; + &quot; constructor accessible&quot;); } else if (clazz == Method.class) { throw new SecurityException(&quot;Can not make a java.lang.reflect.Method&quot; + &quot; constructor accessible&quot;); } else if (clazz == Field.class) { throw new SecurityException(&quot;Can not make a java.lang.reflect.Field&quot; + &quot; constructor accessible&quot;); } } obj.override = flag; } 设置flag为true，可以压制java的安全检查。于是我就试着对私有的方法和属性进行操作： public class AccessableDemo { public static void main(String[] args) { Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Person&quot;); //获取私有的属性 Field field = c.getDeclaredField(&quot;age&quot;); System.out.println(&quot;获取私有属性&quot; + field); //获取私有的方法 Method method = c.getDeclaredMethod(&quot;Somking&quot;, null); System.out.println(method); //使用空参构造动态实例化对象 Person p = (Person) c.newInstance(); //访问私有属性 field.setAccessible(true); field.set(p, 20); //调用私有方法 method.setAccessible(true); method.invoke(p, null); //验证私有属性的访问 System.out.println(p.getAge()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } 结果是实现了通过反射对类私有属性和私有方法的访问。 总结 通过反射获取类的属性、方法、接口、该类的父类、以及通过反射实现Array工具类对数组的操作。 通过反射访问类中私有的属性和方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java反射（reflection）详解]]></title>
      <url>%2F2017%2F03%2F13%2F%E5%8F%8D%E5%B0%84_1%2F</url>
      <content type="text"><![CDATA[写在前面 前几天在网上看到了一篇基于AOP编程的代码，里面用到了动态代理，还有Annotation，感觉比较先进，想分析一下，然后又重新拾起了javase中的反射温习了一遍。并在blog中记录下来。 什么是反射JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。–from 百度 我理解的反射：在运行时，你获取了一个指向某个编译时不存在你的程序空间中的对象的引用，并且可以获取这个引用的属性和方法以及构造方法。 至于编译时、运行时、编译型语言、解释型语言、类加载器、动态加载类，这些概念大体解释一下： 编译时：将.java文件转换成.class文件的过程。 运行时:程序的执行过程，在java中类加载器加载.class文件，并交给jvm处理的过程。 编译型语言：将源代码一次性全部转换为机器代码（二进制代码），然后再执行程序，以后执行这个程序时就不需要再编译了。例如：C\C++编译一次后就直接生成机器语言。 解释型语言：是在运行的时候将程序翻译成机器语言，所以运行速度相对于编译型语言要慢。例如：java\C#，虽然java在执行之前要进行一次编译，但是编译生成的不是机器语言，所以说java也是一种解释性语言。脚本语言是解释型语言。 编译型语言和解释型语言的区别：编译型语言效率高，依赖于编译器，但是跨平台差。解释型的效率低，依赖于解释器，但跨平台强。 类加载器：类加载器就是JVM中的类装载器，作用就是将编译好的.class字节码运到检查器进行安全检查的，检查通过后开始解释执行。 运行时动态加载类：利用反射的原理，调用Class.forName(“ClassName”)方法，获取到的某个类（拿到的不是类的对象）。 静态加载类：new ClassName()。与运行时动态加载类的区别就是：静态加载类在编译时该类不能缺席(会报错)，但是运行时动态加载类在编译时，该类可以缺席（不会报错）。 反射的作用 Spring中IOC（控制反转）、AOP（面向方面编程）。 Hibernate框架：关联映射等。 白盒测试、使用无法反编译的API等。 反射相关APIjava.lang包下：Class: 表示一个正在运行的Java应用程序中的类或者接口，是Reflection的起源。 java.lang.reflect包下： Field类：代表类的成员变量（属性） Method类：代表类的方法。 Constructor类：代表类的构造方法。 Array类：提供了动态创建数组以及访问数组的元素的静态方法。 反射的实现生成一个正在运行的类对象，有四种方法： 使用对象的的getClass()方法。 使用static method ClassforName()。 使用.class语法。 如果是java封装类型使用Type语法。 public class ReflectDemo { public static void main(String[] args) { Class&lt;?&gt; c1 = null; Class&lt;?&gt; c2 = null; Class&lt;?&gt; c3 = null; Class&lt;?&gt; c4 = null; c1 = Person.class; try { c2 = Class.forName(&quot;com.example.lwhome.reflectdemo.Person&quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Person p = new Person(); c3 = p.getClass(); c4 = Integer.TYPE; System.out.println(c1.getName()); System.out.println(c2.getName()); System.out.println(c3.getName()); System.out.println(c4.getName()); } } 获取一个类的构造方法有以下四种方式： Constructor getConstructor(Class params)–获得类的指定参数类型的公共构造函数。 Constructor[] getConstructors()–获取类的所有的公共构造函数。 Constructor getDeclaredConstructor(Class params)–获取类的指定参数类型的构造函数（不限制访问级别） Constructor[] getDeclaredConstructor()–获取类所有的构造函数（不限制访问级别） public class ConstructorDemo { public static void main(String[] args){ try { Class&lt;?&gt; c = Class.forName(&quot;com.demo.moutain.reflectdemo.Person&quot;); //方式一：获得所有公有的构造方法 System.out.println(&quot;获取所有的公共类型的构造方法&quot;); Constructor[] constructors = c.getConstructors(); for(int i = 0 ;i&lt;constructors.length;i++){ System.out.println(constructors[i].toGenericString()); } //方式二：获得指定参数类型的共有的构造方法 System.out.println(&quot;获取指定类型的构造方法&quot;); Constructor constructor = c.getConstructor(new Class[]{String.class,int.class}); System.out.println(constructor.toGenericString()); //方式三：获取所有类型的构造方法，不限制级别 System.out.println(&quot;方式三：获取所有类型的构造方法，不限制级别&quot;); Constructor[] cons = c.getDeclaredConstructors(); for(int i =0;i&lt;cons.length;i++){ System.out.println(cons[i].toGenericString()); } //方式四：获取指定参数类型的构造方法，不限制级别 System.out.println(&quot;获取指定类型的构造方法，不限制级别&quot;); Constructor con = c.getDeclaredConstructor(new Class[]{int.class}); System.out.println(con.toGenericString()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } } } 注意：获取指定参数的构造方法的时候，如果获取一个参数的构造方法时可以传null，也可以传一个空的Class[],但是不能传new Class[]{null}。 获取方法时同样注意。 动态实例化一个对象 获取一个类。 获取这个类的构造方法。 利用获取到的构造方法，动态实例化这个对象。 public class DynamicInstanceDemo { public static void main(String[] args){ Class&lt;?&gt; c = null; try { c = Class.forName(&quot;com.demo.moutain.reflectdemo.Person&quot;); Constructor constructor = c.getConstructor(new Class[]{String.class,int.class}); Person p = (Person) constructor.newInstance(&quot;老王&quot;,60); System.out.println(p.toString()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } 结语动态实例化对象可以使用在依赖注入中，也就是我重新看反射的原因。java反射（reflection）详解就先写到这儿。如果文中有错误和不恰当的地方，欢迎留言探讨。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebView中页面的调试环境搭建]]></title>
      <url>%2F2016%2F11%2F29%2FWebView%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[Html页面在WebView中调试的环境搭建准备工作 windows系统 Oracle VM VirtualBox（使用Genymotion所需的环境） Genymotion（Android模拟器） Charles(抓包工具) Chrome浏览器开始搭建 如果你的处理器已经打开支持虚拟化技术的选项，则继续向下进行第二个步骤。如果没有打开，则按照步骤打开处理器的虚拟化技术支持选项，否则无法正常运行Genymotion。这里以联想电脑的ThinkPad为例，其他型号电脑请自行百度。 保存现在电脑上正在操作的文档，并且重启。 当进入开机自检阶段（屏幕显示Lenovo Logo）的时候快速点击F2，进入BIOS设置界面。截图如下：（开机自检页面）(BIOS设置页面）（BIOS设置页面） 进入Virtualization选项并且将其设置为true即可。 安装Oracle VM VirtualBox 如果已经安装过Oracle VM VirtualBox，请直接跳到下一步。 如果没有安装，打开安装文件直接安装即可，安装路径请随意但是不要有中文（切记）。 安装完打开软件。（Oracle VM VirtualBox打开截图） 选择管理–&gt; 导入虚拟电脑 选择安装包里面的Android虚拟机，按照提示导入完成即可。 运行导入的虚拟机。 安装Genymotion 解压安装包中的Genymotion，然后找到Genymotion.exe,这时候就发现了导入到Oracle VM VirtualBox中的虚拟机。 这时候要进行一个网络代理设置：（Genymotion网络代理设置截图）设置这个代理是为了让Charles能够抓到模拟器发出的请求。 设置完代理以后就可以直接运行模拟器了 运行模拟器以后，需要将Genymotion的Wifi设置上网代理，具体修改方法就是进入模拟器的设置页面–&gt; 打开无线网络设置（Wifi设置）–&gt; 找到连接的无线网络（Wired network）并且长按–&gt; 选择Modify netWork –&gt; 选中Show advanced options 参数按照下方截图来填就可以了，注意端口号要和在Oracle VM VirtualBox中设置的端口号一致。 wifi代理设置截图：（wifi网络代理设置截图）设置这个代理是为了让Charles能够抓到模拟器发出的请求。 打开Chrome，在地址栏输入Chrome://inspect。现在应该能够找到你的设备。 为了让Charles能够抓到Chrome的请求，为Chrome安装Proxy SwitchyOmega插件（改插件在安装包里面有），在Chrome中的扩展程序页面可直接拖进安装。 安装完插件以后新增一种情景模式： 对新增的情景模式进行设置： 保存修改后，当使用Charles调试时选择这个情景模式就可以了。 Charles 安装 打开安装包中的Charles文件夹，打开Charles安装包，进行安装。安装完成后会发现是30天的试用版，在Charles文件夹中还有一个Charles.jar，将它复制到安装所在位置的lib文件夹下，替换掉原来的即可。重新打开会发现…。 设置Charles监听的端口： 同样将端口设置为和模拟器的一致。 设置完端口以后，打开Genymotion，访问一个网页，会发现请求已经被Charles抓到了。找到你需要调试的域名，右击–&gt; 选择MappingLocal 按照截图设置 host设置为要拦截的域名（关键字），port就是默认的80即可。localpath就选择你本地的项目所在路径。 经过以上五步的搭建，你就会发现，你在WebView（安卓模拟器）中请求原来的路径时，已经被charles拦截到本地的项目上了。但是这时候没有控制台啊。怎么调试呢？ 打开Chrome进入Chrome://inspect页面，看到你的请求路径，然后点击inspect，就能打开控制台了，但是这一步第一次打开的时候得科学上网。注意：第一次打开一定要科学上网，但是以后打开就不用了，否则会很慢（卡顿）。结语经过上面的搭建，你就可以发现，在webview中的页面可以直接在pc上调试了。附：本教程所需安装包 密码：zy7t下载后可以实现离线安装。如有问题，可以留言。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HelloWorld]]></title>
      <url>%2F2016%2F11%2F29%2FHelloWorld%2F</url>
      <content type="text"><![CDATA[开题 这是我的第一篇博客，我搭建好博客平台已经一个月了，这一个月我的博客上一直是搭建博客的时候的HelloWorld。没有写博客并不是忙，其实是懒了。年轻人是不能够懒的。看似有大把的时间。但是一旦懒了以后，就会发现时间已经偷偷溜走了。所以说，接下来的时间里，无论多忙。我都会保证每周都更新一篇博客。我知道访问量不多，但是就算读者只有我自己，我也会坚持啊。 我的博客主要是一个技术博客我会在博客中分享一些技术贴。总结在开发中遇到的问题，希望和大家一起探讨吧。同时在分享技术之余，也会写一些文。毕竟，会写文是现在的小鲜肉必备的素能之一。不管咋说，改变原来慵懒的生活节奏。做一个积极向上的小鲜肉。有些人才20多岁，但是心态像5、60岁的人（心态不是经验）。有些人5、60岁了，但是心态像一个年轻人。保持一颗年轻的心是很不容易的。希望自己永远年轻吧。 关于未来技术是我的爱好，但是上班不是我的梦想。我有一颗向往自由的心。再给自己一段时间。如果没有大的进展，就去追随自己的梦想。嗯，就这样了。 最后，祝好。]]></content>
    </entry>

    
  
  
</search>
